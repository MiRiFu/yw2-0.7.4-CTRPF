#include "cheats.hpp"
#include <math.h>
/*****************************************************/
/*                                                   */
/*             Generated by OSD Designer             */
/*                  Made by Hidegon                  */
/*  OSD Designer: https://HidegonSan.github.io/OSD/  */
/*                                                   */
/*****************************************************/

namespace CTRPluginFramework
{
	/* Utility functions for OSD */
	// Thanks: https://en.wikipedia.org/wiki/Digital_differential_analyzer_(graphics_algorithm)
	void DrawLine(const Screen &scr, int srcX, int srcY, int dstX, int dstY, const Color &color)
	{
		float x, y, dx, dy, step;
		int i;

		dx = (dstX - srcX);
		dy = (dstY - srcY);

		if (abs(dx) >= abs(dy))
		{
			step = abs(dx);
		}
		else
		{
			step = abs(dy);
		}

		dx = dx / step;
		dy = dy / step;
		x = srcX;
		y = srcY;
		i = 1;

		while (i <= step)
		{
			scr.DrawPixel(x, y, color);
			x = x + dx;
			y = y + dy;
			i++;
		}
	}

	void DrawPlus(const Screen &scr, const std::string &str, u32 posX, u32 posY, u32 borderWidth, u32 padding, const Color &foreground, const Color &background, const Color &border)
	{
		int bgWidth = OSD::GetTextWidth(false, str);
		int height = 10 + padding * 2;

		scr.DrawRect(posX, posY, bgWidth + (borderWidth * 2) + (padding * 2), borderWidth, border);
		scr.DrawRect(posX + borderWidth + padding + bgWidth + padding, posY + borderWidth, borderWidth, height, border);
		scr.DrawRect(posX, posY + borderWidth + height, bgWidth + (borderWidth * 2) + (padding)*2, borderWidth, border);
		scr.DrawRect(posX, posY + borderWidth, borderWidth, height, border);

		scr.DrawRect(
				posX + borderWidth,
				posY + borderWidth,
				bgWidth + padding * 2,
				10 + padding * 2,
				background);

		scr.Draw(
				str,
				posX + borderWidth + padding,
				posY + borderWidth + padding,
				foreground,
				background);
	}

	void DrawSysfontPlus(const Screen &scr, const std::string &str, u32 posX, u32 posY, u32 borderWidth, u32 padding, const Color &foreground = Color::White, const Color &background = Color::Black, const Color &border = Color::White, bool fillBackground = true, bool rightAligned = false)
	{
		int bgWidth = OSD::GetTextWidth(true, str);
		int height = 16 + padding * 2;
		if (rightAligned)
		{
			scr.DrawRect(posX - bgWidth - (borderWidth * 2) - (padding), posY, bgWidth + (borderWidth * 2) + (padding * 2), borderWidth, border);
			scr.DrawRect(posX - borderWidth, posY + borderWidth, borderWidth, height, border);
			scr.DrawRect(posX - bgWidth - (borderWidth * 2) - (padding), posY + borderWidth + height, bgWidth + (borderWidth * 2) + (padding)*2, borderWidth, border);
			scr.DrawRect(posX - bgWidth - (borderWidth * 2) - (padding), posY + borderWidth, borderWidth, height, border);
			if (fillBackground)
			{
				scr.DrawRect(
						posX + borderWidth - bgWidth,
						posY + borderWidth,
						bgWidth + padding * 2,
						16 + padding * 2,
						background);
			}
			scr.DrawSysfont(
					str,
					posX + borderWidth + padding - bgWidth,
					posY + borderWidth + padding,
					foreground);
		}
		else
		{
			scr.DrawRect(posX, posY, bgWidth + (borderWidth * 2) + (padding * 2), borderWidth, border);
			scr.DrawRect(posX + borderWidth + padding + bgWidth + padding, posY + borderWidth, borderWidth, height, border);
			scr.DrawRect(posX, posY + borderWidth + height, bgWidth + (borderWidth * 2) + (padding)*2, borderWidth, border);
			scr.DrawRect(posX, posY + borderWidth, borderWidth, height, border);
			if (fillBackground)
			{
				scr.DrawRect(
						posX + borderWidth,
						posY + borderWidth,
						bgWidth + padding * 2,
						16 + padding * 2,
						background);
			}
			scr.DrawSysfont(
					str,
					posX + borderWidth + padding,
					posY + borderWidth + padding,
					foreground);
		}
	}

	float DegreeToRadian(float degree)
	{
		return degree * (M_PI / 180);
	}

	void DrawCycle(const Screen &scr, u32 x, u32 y, u32 radiusStart, u32 radiusEnd, int start, int end, const Color &color)
	{
		u32 rectLength = (radiusEnd * 2) / 1.41421356237;
		u32 miniRadius = rectLength / 2;

		u32 rectX = x - miniRadius;
		u32 rectY = y - miniRadius;

		if (start == 0 && end == 360 && radiusStart == 0)
		{
			scr.DrawRect(rectX, rectY, rectLength, rectLength, color);
		}
		else
		{
			miniRadius = radiusStart;
		}

		for (int r = miniRadius; r < radiusEnd; r++)
		{
			for (int angle = start; angle < end; angle++)
			{
				scr.DrawPixel(x + cos(DegreeToRadian(angle)) * r, y + sin(DegreeToRadian(angle)) * r, color);
			}
		}
	}
	/* End of Utility functions for OSD */
}